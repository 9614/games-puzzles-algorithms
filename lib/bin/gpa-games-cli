#!/usr/bin/env python3

import argparse
import random

from games_puzzles_algorithms.games.hex.game_state \
    import GameState as HexGameState
from games_puzzles_algorithms.games.hex.color \
    import COLOR_SYMBOLS, color_to_player, COLORS

from games_puzzles_algorithms.games.ttt.game_state \
    import GameState as TttGameState
from games_puzzles_algorithms.games.ttt.game_state \
    import BoardValues as TttBoardValues

from games_puzzles_algorithms.players.rule_based.random_agent \
    import RandomAgent
from games_puzzles_algorithms.players.rule_based.first_action_agent \
    import FirstActionAgent
from games_puzzles_algorithms.players.mcts.mcts_agent import MctsAgent
from games_puzzles_algorithms.players.minimax.minimax_agent import MinimaxAgent

from games_puzzles_algorithms.games.cli import Cli


class UiGameState(object):
    def __init__(self, *args, **kwargs): self.reset(*args, **kwargs)

    def reset(self, *args, **kwargs):
        self.state = self.new_state(*args, **kwargs)
        return self

    def ui_action_to_action(self, ui_action): return ui_action
    def action_to_ui_action(self, action): return action
    def state_to_ui_state(self): return str(self.state)
    def player_to_ui_player(self, player): return player
    def ui_player_to_player(self, ui_player): return ui_player


class HexCliGameState(UiGameState):
    @classmethod
    def new_state(self, *args, **kwargs):
        return HexGameState.root(*args, **kwargs)

    def ui_action_to_action(self, ui_action):
        column = ord(ui_action[0].lower()) - ord('a')
        row = int(ui_action[1:]) - 1
        return self.state.board.cell_index(row, column)

    def action_to_ui_action(self, action):
        row = self.state.board.row(action)
        column = self.state.board.column(action)
        return chr(ord('a') + column) + str(row + 1)

    def player_to_ui_player(self, player): return COLOR_SYMBOLS[player]
    def ui_player_to_player(self, ui_player):
        ui_player = ui_player.strip().lower()
        if (ui_player == 'w' or ui_player == 'white'
                or ui_player
                   == COLOR_SYMBOLS[color_to_player(COLORS['white'])].lower()):
            return color_to_player(COLORS['white'])
        elif (ui_player == 'b' or ui_player == 'black'
                or ui_player
                   == COLOR_SYMBOLS[color_to_player(COLORS['black'])].lower()):
            return color_to_player(COLORS['black'])
        else:
            raise('Unrecognized player, \'{}\''.format(ui_player))

    def reset_state(self):
        self.state.reset(*self.state.board.size())
        return self


class TttCliGameState(UiGameState):
    @classmethod
    def new_state(self, *args, **kwargs):
        return TttGameState(*args, **kwargs)

    def ui_action_to_action(self, ui_action):
        column = ord(ui_action[0].lower()) - ord('a')
        row = int(ui_action[1:]) - 1
        return self.state.cell_index(row, column)

    def action_to_ui_action(self, action):
        row = self.state.row(action)
        column = self.state.column(action)
        return chr(ord('a') + column) + str(row + 1)

    def player_to_ui_player(self, player):
        return str(TttBoardValues(player))

    def ui_player_to_player(self, ui_player):
        return TttBoardValues[ui_player.upper()]

    def reset_state(self):
        self.state.reset()
        return self


GAMES = {'hex': HexCliGameState, 'ttt': TttCliGameState}
ALGS = {
    'random': lambda **kwargs: RandomAgent(kwargs['random_generator'].random),
    'first': lambda **_: FirstActionAgent(),
    'MCTS': lambda **kwargs: MctsAgent(kwargs['random_generator']),
    'minimax': lambda **_: MinimaxAgent()}

DEFAULT_GAME = 'hex'
DEFAULT_ALG = 'MCTS'

if __name__ == '__main__':
    parser = argparse.ArgumentParser('Interact with a game agent using the GTP'
                                     'protocol.')

    parser.add_argument('-r', '--random-seed', type=int,
                        help=('A seed for agents with randomness. Defaults to '
                              'system time.'))
    parser.add_argument('-s', '--script',
                        help='A script of commands to play out.')
    parser.add_argument('-g', '--game', choices=GAMES.keys(),
                        default=DEFAULT_GAME,
                        help=('The game to play. Default is %(default)s.'))
    parser.add_argument('-a', '--algorithm', choices=ALGS.keys(),
                        default=DEFAULT_ALG,
                        help=('The algorithm to use to play the selected game. '
                              'Default is %(default)s.'))
    parser.add_argument('-v', '--verbose', action='store_true',
                        help='Show verbose output.')

    args = parser.parse_args()
    r = random.Random(args.random_seed)

    game = GAMES[args.game]
    algorithm = ALGS[args.algorithm]

    if args.verbose:
        import logging
        logging.basicConfig(level=logging.DEBUG)

    try:
        cli = Cli(game(), algorithm(random_generator=r))
        if args.script is not None:
            with open(args.script) as f:
                for command in f:
                    command = command.strip()
                    print('< ' + command)
                    cli.onecmd(command)
        cli.cmdloop()
    except KeyboardInterrupt:
        pass
